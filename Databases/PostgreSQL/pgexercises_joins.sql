/* 
	the following queries represent solutions to the same example;
	however, the first option must repeat the logic in the `CASE`
	statement in the `WHERE` clause because the data generated by
	the `CASE` statement cannot be used for comparison. The second 
	example does uses a subquery, and thus can effectively use this 
	column for comparison in the `WHERE` clause.

	PROMPT:
	How can you produce a list of bookings on the day of 2012-09-14
	which will cost the member (or guest) more than $30? Remember that
	guests have different costs to members (the listed costs are per
	half-hour 'slot'), and the guest user is always ID 0. Include in your
	output the name of the facility, the name of the member formatted as
	a single column, and the cost. Order by descending cost.

	see [here](https://www.pgexercises.com/questions/joins/threejoin2.html)
	for the schema of data being used
*/

-- [no subquery](https://www.pgexercises.com/questions/joins/threejoin2.html)
SELECT firstname || ' ' || surname member,
	name facility,
	CASE bks.memid
		WHEN 0 THEN guestcost * slots
		ELSE membercost * slots
	END AS cost
	FROM
		cd.members mems
		JOIN cd.bookings bks
			ON mems.memid = bks.memid
		JOIN cd.facilities facs
			ON bks.facid = facs.facid
	WHERE (
		starttime BETWEEN '2012-09-14' AND '2012-09-15'AND (
			/*
				this logic is repeated from the `CASE` statement
				because the column created by the `CASE` statement
				cannot be referenced in the `WHERE` clause
				
				QUESTION: Why is this? Is this rule specific
				to case statements or does it apply to aggregate
				functions too?

				ANSWER: making an alias for an aggregate function
				has the same behavior; it cannot be used in a
				`WHERE` or a `HAVING` clause. Final question then
				becomes why can it be used in an `ORDER BY` or a
				`GROUP BY`? What are the differences between these
				statements?
				ANSWER: Postgres just doesn't support column names in
				a `HAVING` clause; `HAVING` is strictly for aggregate
				functions. Other RDBMSs like SQL Server and MySQL do
				support this behavior.
			*/
		  (bks.memid = 0 AND guestcost * slots > 30.0) OR
		  (bks.memid != 0 AND membercost * slots > 30.0)
		)
	)
	ORDER BY cost DESC;

-- [subquery](https://www.pgexercises.com/questions/joins/tjsub.html)
SELECT member, facility, cost
	FROM (
		-- can select from the result of a subquery
		-- rather than from existing tables
	  SELECT mems.firstname || ' ' || mems.surname member,
		facs.name facility,
		CASE mems.memid
		  WHEN 0 THEN facs.guestcost * bks.slots
		  ELSE facs.membercost * bks.slots
		END AS cost
		FROM 
		  cd.members mems
		  JOIN cd.bookings bks
			  ON mems.memid = bks.memid
		  JOIN cd.facilities facs
			  ON bks.facid = facs.facid
		WHERE (
			bks.starttime BETWEEN 
				'2012-09-14' AND '2012-09-15'
		)
	ORDER BY cost DESC
  ) AS valid_bookings
  -- can use this column in the `WHERE` clause
  -- now because it isn't extrapolated anymore
  WHERE cost > 30.0;
